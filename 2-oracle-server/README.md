# Low-Overhead Oracle Server (Netlify + Express + TypeScript)

This project implements a lightweight **Oracle Server** for the Noir Circuit. It serves external data (like cryptocurrency prices) via a JSON-RPC 2.0 interface. 

It is designed to run as a **Serverless Function** on Netlify, avoiding the need for dedicated hosting or complex infrastructure.

## ğŸ“‚ Project Structure

```text
2-oracle-server/
â”œâ”€â”€ netlify/
â”‚   â””â”€â”€ functions/
â”‚       â””â”€â”€ api.ts       # âš¡ Serverless Entry Point: Wraps Express for Netlify
â”œâ”€â”€ src/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ index.ts     # ğŸ§  Core Logic: Express App & JSON-RPC Handlers
â”œâ”€â”€ dist/                # ğŸ“¦ Build Output (Generated by npm run build)
â”œâ”€â”€ netlify.toml         # âš™ï¸ Netlify Config: Redirects traffic to the function
â”œâ”€â”€ package.json         # ğŸ“¦ Dependencies (Express, json-rpc-2.0, serverless-http)
â””â”€â”€ tsconfig.json        # ğŸ› ï¸ TypeScript Config: optimized for serverless build
```

---

## ğŸš€ Getting Started

### Prerequisites
- **Node.js** (v18+ recommended)
- **Netlify CLI** (`npm install -g netlify-cli`)

### Installation
```bash
cd 2-oracle-server
npm install
```

### Local Development
Run the server locally using `nodemon` for hot-reloading:
```bash
npm run dev
```
The server will start at `http://localhost:5555`.

---

## ğŸ› ï¸ How to Modify & Add Logic

The core logic lives in `src/api/index.ts`. This is a standard Express application using the `json-rpc-2.0` library.

### api/index.ts
This file sets up the JSON-RPC server. To add new capabilities to your oracle, you verify the method name and return the appropriate data.

**Example: Adding a BTC Price Oracle**

1.  Open `src/api/index.ts`.
2.  Locate the `server.addMethod` block.
3.  Add a new condition for BTC:

```typescript
// inside server.addMethod('resolve_foreign_call', ...)
const funcName = params[0].function;

if (funcName === 'fetchEthPrice') {
    return { values: ["2850"] }; // Mocked ETH Price
} else if (funcName === 'fetchBtcPrice') {
    // Add logic here (e.g., fetch from API)
    return { values: ["65000"] }; 
} else {
    throw new Error(`Unknown oracle: ${funcName}`);
}
```

---

## ğŸ—ï¸ Architecture Guide: How to build this from scratch

If you want to understand how to build a TypeScript Express app deploying to Netlify, here is the step-by-step recipe used to create this project.

### Step 1: Initialize Project & Install Dependencies
Initialize a Node project and install `express` (web server), `serverless-http` (adapter for Netlify), and `json-rpc-2.0` (protocol).
```bash
npm init -y
npm install express serverless-http json-rpc-2.0 body-parser cors
npm install -D typescript @types/node @types/express @types/cors ts-node nodemon
```

### Step 2: Configure TypeScript (`tsconfig.json`)
Crucial settings for Netlify Functions:
- `module`: `"nodenext"` or `"commonjs"`
- `outDir`: `"./dist"`
- **Important**: Set `"declaration": false` and `"sourceMap": false`. Netlify will confuse definition files with actual functions if they are generated in the output folder.

### Step 3: Create the Express App (`src/api/index.ts`)
Write standard Express code.
- **Tip**: Do NOT verify `app.listen()` inside the main file unless wrapped in a conditional check (like `!process.env.NETLIFY`). In serverless, the provider handles calling the function, not the app listening on a port.

### Step 4: Create the Serverless Adapter (`netlify/functions/api.ts`)
This file bridges the gap between Netlify's event format and Express's request/response objects.

```typescript
import serverless from 'serverless-http';
import app from '../../src/api/index.js'; // Note .js extension for ESM handling

// Fix for some ESM environments needing explicit default export handling
const expressApp = (app as any).default || app;
export const handler = serverless(expressApp);
```

### Step 5: Configure Netlify (`netlify.toml`)
Tell Netlify to redirect all traffic (`/*`) to our function. This allows Express to handle routing internally.

```toml
[build]
  command = "npm run build"
  functions = "dist/netlify/functions" # Where TS compiles to

[[redirects]]
  from = "/*"
  to = "/.netlify/functions/api"
  status = 200
  force = true
```

---

## â˜ï¸ Deployment

We use **TypeScript**, so the code must be compiled before deployment.

### 1. Build
```bash
npm run build
```
This runs `tsc` and outputs JavaScript to the `dist/` folder.

### 2. Deploy to Production
```bash
npx netlify deploy --prod
```
Netlify will bundle the `dist/netlify/functions/api.js` file and code accessible via `import`.

**Current Deployment**: `https://starlit-bubblegum-c0e20b.netlify.app`

---

## ğŸ§ª Testing

### Test with Curl
Check if the server is healthy:
```bash
curl https://starlit-bubblegum-c0e20b.netlify.app/test
```

Test the Oracle JSON-RPC:
```bash
curl -X POST -H "Content-Type: application/json" \
     -d '{"jsonrpc": "2.0", "method": "resolve_foreign_call", "params": [{"function": "fetchEthPrice", "inputs": []}], "id": 1}' \
     https://starlit-bubblegum-c0e20b.netlify.app/
```

### Test with Noir
Run the circuit test using the deployed oracle as a resolver:
```bash
cd ../1-noir-circuit/eth_price_circuit
nargo test --oracle-resolver https://starlit-bubblegum-c0e20b.netlify.app
```
